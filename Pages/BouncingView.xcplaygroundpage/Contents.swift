/*:
# Bouncing View

다음의 내용을 연습한다.
- extension, protocol
- drawing with Core Graphics API
- dispatch_after()를 이용한 무한 반복
- bounds과 frame의 관계
*/

import Foundation
import UIKit

class MovingController:NSObject {
    var movingDirection: CGVector

    var view:UIView?

    init(view:UIView, direction:CGVector) {
        self.view = view
        self.movingDirection = direction
    }
    init(view:UIView, dx: CGFloat, dy: CGFloat) {
        self.view = view
        self.movingDirection = CGVector(dx: dx, dy: dy)
    }

    func moveNext() {
        guard let view = self.view else { return }
        guard let superview = view.superview else { return }

        var offsetX:CGFloat = self.movingDirection.dx
        var offsetY:CGFloat = self.movingDirection.dy

        // candidate
        let nextFrame = CGRectOffset(view.frame, offsetX, offsetY)

        let superviewTL = CGPointMake(CGRectGetMinX(superview.bounds), CGRectGetMinY(superview.bounds))
        let superviewBR = CGPointMake(CGRectGetMaxX(superview.bounds), CGRectGetMaxY(superview.bounds))

        let nextTL = CGPointMake(CGRectGetMinX(nextFrame), CGRectGetMinY(nextFrame))
        let nextBR = CGPointMake(CGRectGetMaxX(nextFrame), CGRectGetMaxY(nextFrame))


        // reflect in X
        if (nextTL.x < superviewTL.x) {
            offsetX = superviewTL.x - nextTL.x
            self.movingDirection.dx = -self.movingDirection.dx
        }
        else if (superviewBR.x < nextBR.x) {
            offsetX = superviewBR.x - nextBR.x
            self.movingDirection.dx = -self.movingDirection.dx
        }

        // reflect in Y
        if (nextTL.y < superviewTL.y) {
            offsetY = superviewTL.y - nextTL.y
            self.movingDirection.dy = -self.movingDirection.dy
        }
        else if (superviewBR.y < nextBR.y) {
            offsetY = superviewBR.y - nextBR.y
            self.movingDirection.dy = -self.movingDirection.dy
        }

        view.frame = CGRectOffset(view.frame, offsetX, offsetY)
    }
}

protocol MovingViewProtocol {
    var movingController: MovingController? { get }
}

//
// extension을 통해서는 stored property를 추가할 수 없기 때문에
// 필요한 클래스에서 각자 추가를 하고 computed property를 override하고 있다.
//
extension UIView: MovingViewProtocol {
    var movingController: MovingController? {
        get {
            return nil;
            //            let selector: Selector = "movingController"
            //            let _movingController = self.performSelector(selector).takeUnretainedValue() as? MovingController
            //
            //            return _movingController
        }
    }
}

class MovingView: UIView {
    lazy private var _movingController:MovingController = MovingController(view: self, dx: 1.0, dy: 1.0)
    override var movingController: MovingController? {
        get {
            return _movingController
        }
    }
}

class MovingLabel: UILabel {
    lazy private var _movingController:MovingController = MovingController(view: self, dx: 1.0, dy: 1.0)
    override var movingController: MovingController? {
        get {
            return _movingController
        }
    }
}

class MovingCircle: UIView {
    lazy private var _movingController:MovingController = MovingController(view: self, dx: 1.0, dy: 1.0)
    override var movingController: MovingController? {
        get {
            return _movingController
        }
    }
    override func drawRect(rect: CGRect) {
        //let p = UIBezierPath(ovalInRect: CGRectMake(0,0,100,100))
        let p = UIBezierPath(ovalInRect:rect)
        //self.backgroundColor?.setFill()
        UIColor.blueColor().setFill()
        p.fill()
    }
}

class MovingStar: UIView {
    lazy private var _movingController:MovingController = MovingController(view: self, dx: 1.0, dy: 1.0)
    override var movingController: MovingController? {
        get {
            return _movingController
        }
    }
    override func drawRect(rect: CGRect) {
        //// Generated by PaintCode

        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let color = UIColor(red: 0.958, green: 0.839, blue: 0.043, alpha: 1.000)

        //// Shadow Declarations
        let shadow2 = NSShadow()
        shadow2.shadowColor = UIColor.whiteColor()
        shadow2.shadowOffset = CGSizeMake(0.1, -0.1)
        shadow2.shadowBlurRadius = 20

        //// Star Drawing
        CGContextSaveGState(context)
        CGContextTranslateCTM(context, -7.22, 10.91)
        CGContextRotateCTM(context, -25 * CGFloat(M_PI) / 180)

        let starPath = UIBezierPath()
        starPath.moveToPoint(CGPointMake(25, 0))
        starPath.addLineToPoint(CGPointMake(33.82, 12.86))
        starPath.addLineToPoint(CGPointMake(48.78, 17.27))
        starPath.addLineToPoint(CGPointMake(39.27, 29.64))
        starPath.addLineToPoint(CGPointMake(39.69, 45.23))
        starPath.addLineToPoint(CGPointMake(25, 40))
        starPath.addLineToPoint(CGPointMake(10.31, 45.23))
        starPath.addLineToPoint(CGPointMake(10.73, 29.64))
        starPath.addLineToPoint(CGPointMake(1.22, 17.27))
        starPath.addLineToPoint(CGPointMake(16.18, 12.86))
        starPath.closePath()
        color.setFill()
        starPath.fill()

        ////// Star Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, starPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((shadow2.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let starOpaqueShadow = (shadow2.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, shadow2.shadowOffset, shadow2.shadowBlurRadius, starOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, .SourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        starOpaqueShadow.setFill()
        starPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)


        CGContextRestoreGState(context)
    }
}

class ViewController: UIViewController {
    var topContainerView: UIView!
    var bottomContainerView: UIView!

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.

        self.topContainerView = UIView(frame: CGRectMake(0, 0, 320, 240))
        self.bottomContainerView = UIView(frame: CGRectMake(0, 240, 320, 240))

        self.view.addSubview(self.topContainerView)
        self.view.addSubview(self.bottomContainerView)

        if let containerView = self.topContainerView {
            containerView.layer.borderWidth = 2
            containerView.layer.borderColor = UIColor.redColor().CGColor

            let v1 = MovingView(frame: CGRectMake(0,0,20,20))
            v1.backgroundColor = UIColor.redColor()
            v1.movingController!.movingDirection = CGVectorMake(10,5)
            containerView.addSubview(v1)

            let v2 = MovingCircle(frame: CGRectMake(100, 200, 40, 30))
            v2.backgroundColor = UIColor.clearColor()
            containerView.addSubview(v2)

            let v3 = MovingStar(frame: CGRectMake(100, 100, 50, 50))
            v3.backgroundColor = UIColor.clearColor()
            v3.movingController!.movingDirection = CGVectorMake(2,-3)
            containerView.addSubview(v3)
        }

        if let containerView = self.bottomContainerView {
            containerView.layer.borderWidth = 2
            containerView.layer.borderColor = UIColor.blueColor().CGColor

            let v1 = MovingLabel(frame: CGRectMake(0,0,40,20))
            v1.textColor = UIColor.redColor()
            v1.text = "저기요?"
            v1.sizeToFit()
            containerView.addSubview(v1)

            let v2 = MovingLabel(frame: CGRectMake(100, 200, 40, 20))
            v2.textColor = UIColor.greenColor()
            v2.text = "왜요?"
            v2.sizeToFit()
            containerView.addSubview(v2)

        }
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    override func viewDidAppear(animated: Bool) {
        super.viewDidAppear(animated)

        self.foreverMoveNext()
    }

    func foreverMoveNext() {
        for movingView in self.topContainerView.subviews {
            if let movingController = movingView.movingController {
                movingController.moveNext()
            }
        }

        for movingView in self.bottomContainerView.subviews {
            if let movingController = movingView.movingController {
                movingController.moveNext()
            }
        }

        self.runActionAfterTime((1.0 / 100.0), action: self.foreverMoveNext)
    }

    func runActionAfterTime(second:Float, action:() -> Void) {
        let delayTime = dispatch_time(DISPATCH_TIME_NOW, Int64(Double(second) * Double(NSEC_PER_SEC)))
        
        dispatch_after(delayTime, dispatch_get_main_queue(), action)
    }
}

PlaygroundHelper.showViewController(ViewController())


